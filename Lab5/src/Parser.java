import java.util.*;

public class Parser {
    private final Grammar grammar;
    private HashMap<String, Set<String>> firstSet;
    private HashMap<String, Set<String>> followSet;
    private HashMap<Pair, Pair> parseTable;
    private List<List<String>> productionsRhs;

    public Parser(Grammar grammar) {
        this.grammar = grammar;
        this.firstSet = new HashMap<>();
        this.followSet = new HashMap<>();
        this.parseTable = new HashMap<>();

        generateFirst();
        generateFollow();
        generateParseTable();
    }

    public void generateFirst() {
        //initialize the first set by adding all terminal symbols that can appear at the beginning of any production that starts with a non-terminal
        for (String nonterminal : grammar.getN()) {
            firstSet.put(nonterminal, new HashSet<>());
            Set<List<String>> productionForNonterminal = grammar.getProductionForNonterminal(nonterminal);
            for (List<String> production : productionForNonterminal) {
                //if the first symbol of the production is a terminal symbol or the empty string, add it to the first set
                if (grammar.getE().contains(production.get(0)) || production.get(0).equals("epsilon"))
                    firstSet.get(nonterminal).add(production.get(0));
            }
        }

        //continue iterating until the first set no longer changes
        var isChanged = true;
        while (isChanged) {
            isChanged = false;
            //create a new map to store the updated first set
            HashMap<String, Set<String>> newColumn = new HashMap<>();

            for (String nonterminal : grammar.getN()) {
                //retrieve the set of productions that can be generated by the non-terminal symbol
                Set<List<String>> productionForNonterminal = grammar.getProductionForNonterminal(nonterminal);
                //take the union of the current first set and the set of terminal symbols that can appear at the beginning of the production, after removing any non-terminal symbols from the beginning of the production
                Set<String> toAdd = new HashSet<>(firstSet.get(nonterminal));
                for (List<String> production : productionForNonterminal) {
                    //create a list of non-terminal symbols on the right-hand side of the production
                    List<String> rhsNonTerminals = new ArrayList<>();
                    //create a variable to store the first terminal symbol on the right-hand side of the production
                    String rhsTerminal = null;
                    for (String symbol : production) {
                        //if the symbol is a non-terminal, add it to the list of non-terminal symbols
                        if (this.grammar.getN().contains(symbol))
                            rhsNonTerminals.add(symbol);
                        else {
                            //if the symbol is a terminal, store it in the rhsTerminal variable and stop iterating
                            rhsTerminal = symbol;
                            break;
                        }
                    }
                    //add the concatenation of the first sets of the non-terminal symbols in the rhsNonTerminals list and the rhsTerminal symbol to the toAdd set
                    toAdd.addAll(concatenationOfSizeOne(rhsNonTerminals, rhsTerminal));
                }
                //if the first set for the non-terminal has changed, update the first set and set isChanged to true
                if (!toAdd.equals(firstSet.get(nonterminal))) {
                    isChanged = true;
                }
                newColumn.put(nonterminal, toAdd);
            }
            firstSet = newColumn;
        }
    }

    private Set<String> concatenationOfSizeOne(List<String> nonTerminals, String terminal) {
        if (nonTerminals.size() == 0) {
// If the list of nonterminals is empty, return an empty set.
            return new HashSet<>();
        }
        if (nonTerminals.size() == 1) {
// If there is only one nonterminal in the list, return its first set.
            return firstSet.get(nonTerminals.iterator().next());
        }

        // Create an empty set to hold the concatenation of the first sets.
        Set<String> concatenation = new HashSet<>();

        // Initialize a step counter and a flag to track whether all of the nonterminals have epsilon in their first sets.
        var step = 0;
        var allEpsilon = true;

        // Check whether each nonterminal has epsilon in its first set.
        for (String nonTerminal : nonTerminals) {
            if (!firstSet.get(nonTerminal).contains("epsilon")) {
                allEpsilon = false;
            }
        }

        // If all nonterminals have epsilon in their first sets, add the terminal or "epsilon" to the concatenation set.
        if (allEpsilon) {
            concatenation.add(Objects.requireNonNullElse(terminal, "epsilon"));
        }

        // Iterate over the nonterminals and check for epsilon in their first sets.
        while (step < nonTerminals.size()) {
            boolean thereIsOneEpsilon = false;
            for (String s : firstSet.get(nonTerminals.get(step)))
                if (s.equals("epsilon")) {
                    // If a nonterminal has epsilon in its first set, set the flag to true.
                    thereIsOneEpsilon = true;
                } else {
                    // Otherwise, add the terminal to the concatenation set.
                    concatenation.add(s);
                }

            // If a nonterminal has epsilon in its first set, move on to the next nonterminal.
            if (thereIsOneEpsilon) {
                step++;
            } else {
                // If a nonterminal does not have epsilon in its first set, exit the loop.
                break;
            }
        }

        // Return the concatenation set.
        return concatenation;
    }

    public void generateFollow() {
// initializes the follow set for each non-terminal in the grammar
        for (String nonterminal : grammar.getN()) {
            followSet.put(nonterminal, new HashSet<>());
        }
// adds "epsilon" to the follow set of the starting symbol of the grammar
        followSet.get(grammar.getS()).add("epsilon");

// continues looping until the follow set is stable
        var isChanged = true;
        while (isChanged) {
            isChanged = false;
// creates a new column for the follow set
            HashMap<String, Set<String>> newColumn = new HashMap<>();

// iterate through each nonterminal in the grammar
            for (String nonterminal : grammar.getN()) {
// initialize an empty set in the newColumn HashMap to store the follow set for this nonterminal
                newColumn.put(nonterminal, new HashSet<>());
                var productionsWithNonterminalInRhs = new HashMap<String, Set<List<String>>>();
                var allProductions = grammar.getP();
                //For each production, the code checks if the production contains the given nonterminal.
                // If it does, the code adds the production to the productionsWithNonterminalInRhs map.
                // It does this by getting the key (i.e., the LHS nonterminal) of the production, and then checking if
                // the productionsWithNonterminalInRhs map already contains an entry for this key. If it doesn't,
                // the code adds a new entry to the map, with an empty set as the value.
                allProductions.forEach((k, v) -> {
                    for (var eachProduction : v) {
                        if (eachProduction.contains(nonterminal)) {
                            var key = k.iterator().next();
                            if (!productionsWithNonterminalInRhs.containsKey(key))
                                productionsWithNonterminalInRhs.put(key, new HashSet<>());
                            productionsWithNonterminalInRhs.get(key).add(eachProduction);
                        }
                    }
                });
                var toAdd = new HashSet<>(followSet.get(nonterminal));
                productionsWithNonterminalInRhs.forEach((k, v) -> {
                    for (var production : v) {
                        var productionList = (ArrayList<String>) production;
                        for (var indexOfNonterminal = 0; indexOfNonterminal < productionList.size(); ++indexOfNonterminal)
                            if (productionList.get(indexOfNonterminal).equals(nonterminal)) {
                                if (indexOfNonterminal + 1 == productionList.size()) {
                                    toAdd.addAll(followSet.get(k));
                                } else {
                                    var followSymbol = productionList.get(indexOfNonterminal + 1);
                                    if (grammar.getE().contains(followSymbol))
                                        toAdd.add(followSymbol);
                                    else {
                                        for (var symbol : firstSet.get(followSymbol)) {
                                            if (symbol.equals("epsilon"))
                                                toAdd.addAll(followSet.get(k));
                                            else
                                                toAdd.addAll(firstSet.get(followSymbol));
                                        }
                                    }
                                }
                            }
                    }
                });
                //After processing all the productions, the toAdd set will contain the updated follow set for the nonterminal
                if (!toAdd.equals(followSet.get(nonterminal))) {
                    isChanged = true;
                }
                newColumn.put(nonterminal, toAdd);
            }

            followSet = newColumn;

        }
    }

    public void generateParseTable() {
        List<String> rows = new ArrayList<>();
        rows.addAll(grammar.getN());
        rows.addAll(grammar.getE());
        rows.add("$");

        List<String> columns = new ArrayList<>();
        columns.addAll(grammar.getE());
        columns.add("$");

        for (var row : rows)
            for (var col : columns)
                parseTable.put(new Pair<String, String>(row, col), new Pair<String, Integer>("err",-1));

        for (var col : columns)
            parseTable.put(new Pair<String, String>(col, col), new Pair<String, Integer>("pop",-1));

        parseTable.put(new Pair<String, String>("$", "$"), new Pair<String, Integer>("acc",-1));

        var productions = grammar.getP();
        this.productionsRhs = new ArrayList<>();
        productions.forEach((k,v) -> {
            var nonterminal = k.iterator().next();
            for(var prod : v)
                if(!prod.get(0).equals("epsilon"))
                    productionsRhs.add(prod);
                else {
                    productionsRhs.add(new ArrayList<>(List.of("epsilon", nonterminal)));
                }
        });

        System.out.println(productionsRhs);

        productions.forEach((k, v) -> {
            var key = k.iterator().next();

            for (var production : v) {
                var firstSymbol = production.get(0);
                if (grammar.getE().contains(firstSymbol))
                    if (parseTable.get(new Pair<>(key, firstSymbol)).getFirst().equals("err"))
                        parseTable.put(new Pair<>(key, firstSymbol), new Pair<>(String.join(" ", production),productionsRhs.indexOf(production)+1));
                    else {
                        try {
                            throw new IllegalAccessException("CONFLICT: Pair "+key+","+firstSymbol);
                        } catch (IllegalAccessException e) {
                            e.printStackTrace();
                        }
                    }
                else if (grammar.getN().contains(firstSymbol)) {
                    if (production.size() == 1)
                        for (var symbol : firstSet.get(firstSymbol))
                            if (parseTable.get(new Pair<>(key, symbol)).getFirst().equals("err"))
                                parseTable.put(new Pair<>(key, symbol), new Pair<>(String.join(" ", production),productionsRhs.indexOf(production)+1));
                            else {
                                try {
                                    throw new IllegalAccessException("CONFLICT: Pair "+key+","+symbol);
                                } catch (IllegalAccessException e) {
                                    e.printStackTrace();
                                }
                            }
                    else {
                        var i = 1;
                        var nextSymbol = production.get(1);
                        var firstSetForProduction = firstSet.get(firstSymbol);

                        while (i < production.size() && grammar.getN().contains(nextSymbol)) {
                            var firstForNext = firstSet.get(nextSymbol);
                            if (firstSetForProduction.contains("epsilon")) {
                                firstSetForProduction.remove("epsilon");
                                firstSetForProduction.addAll(firstForNext);
                            }

                            i++;
                            if (i < production.size())
                                nextSymbol = production.get(i);
                        }

                        for (var symbol : firstSetForProduction) {
                            if (symbol.equals("epsilon"))
                                symbol = "$";
                            if (parseTable.get(new Pair<>(key, symbol)).getFirst().equals("err"))
                                parseTable.put(new Pair<>(key, symbol), new Pair<>(String.join(" ", production), productionsRhs.indexOf(production) + 1));
                            else {
                                try {
                                    throw new IllegalAccessException("CONFLICT: Pair " + key + "," + symbol);
                                } catch (IllegalAccessException e) {
                                    e.printStackTrace();
                                }
                            }
                        }
                    }
                } else {
                    var follow = followSet.get(key);
                    for (var symbol : follow) {
                        if (symbol.equals("epsilon")) {
                            if (parseTable.get(new Pair<>(key, "$")).getFirst().equals("err")) {
                                var prod = new ArrayList<>(List.of("epsilon",key));
                                parseTable.put(new Pair<>(key, "$"), new Pair<>("epsilon", productionsRhs.indexOf(prod) + 1));
                            }
                            else {
                                try {
                                    throw new IllegalAccessException("CONFLICT: Pair "+key+","+symbol);
                                } catch (IllegalAccessException e) {
                                    e.printStackTrace();
                                }
                            }
                        } else if (parseTable.get(new Pair<>(key, symbol)).getFirst().equals("err")) {
                            var prod = new ArrayList<>(List.of("epsilon",key));
                            parseTable.put(new Pair<>(key, symbol), new Pair<>("epsilon", productionsRhs.indexOf(prod) + 1));
                        }
                        else {
                            try {
                                throw new IllegalAccessException("CONFLICT: Pair "+key+","+symbol);
                            } catch (IllegalAccessException e) {
                                e.printStackTrace();
                            }
                        }
                    }
                }
            }
        });

    }


    public String printFirst() {
        StringBuilder builder = new StringBuilder();
        firstSet.forEach((k, v) -> {
            builder.append(k).append(": ").append(v).append("\n");
        });
        return builder.toString();
    }

    public String printFollow() {
        StringBuilder builder = new StringBuilder();
        followSet.forEach((k, v) -> {
            builder.append(k).append(": ").append(v).append("\n");
        });
        return builder.toString();
    }

    public String printParseTable() {
        StringBuilder builder = new StringBuilder();
        parseTable.forEach((k, v) -> {
            builder.append(k).append(" -> ").append(v).append("\n");
        });
        return builder.toString();
    }

    public List<Integer> parseSequence(List<String> sequence){
        Stack<String> alpha = new Stack<>();
        Stack<String> beta = new Stack<>();
        List<Integer> result = new ArrayList<>();

        //initialization
        alpha.push("$");
        for(var i=sequence.size()-1;i>=0;--i)
            alpha.push(sequence.get(i));

        beta.push("$");
        beta.push(grammar.getS());

        while(!(alpha.peek().equals("$") && beta.peek().equals("$"))){
            String alphaPeek = alpha.peek();
            String betaPeek = beta.peek();
            Pair<String,String> key = new Pair<>(betaPeek,alphaPeek);
            Pair<String,Integer> value = parseTable.get(key);

            if(!value.getFirst().equals("err")){
                if(value.getFirst().equals("pop")){
                    alpha.pop();
                    beta.pop();
                }
                else {
                    beta.pop();
                    if(!value.getFirst().equals("epsilon")) {
                        String[] val = value.getFirst().split(" ");
                        for (var i = val.length - 1; i >= 0; --i)
                            beta.push(val[i]);
                    }
                    result.add(value.getSecond());
                }
            }
            else {
                System.out.println("Syntax error for key "+key);
                System.out.println("Current alpha and beta for sequence parsing:");
                System.out.println(alpha);
                System.out.println(beta);
                result = new ArrayList<>(List.of(-1));
                return result;
            }
        }

        return result;
    }

    public List<String> getProductionByOrderNumber(int order){
        var production = productionsRhs.get(order-1);
        if(production.contains("epsilon"))
            return List.of("epsilon");
        return production;
    }

    public Grammar getGrammar() {
        return grammar;
    }

    public List<List<String>> getProductionsRhs() {
        return productionsRhs;
    }
}